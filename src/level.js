//@ sourceMappingURL=level.map
// Generated by CoffeeScript 1.6.1
(function() {
  var COORDS, Camera, KEY, LIGHT_TOPOLOGY, Level, RENDER_MIRRORS, mirrors;

  LIGHT_TOPOLOGY = 8;

  RENDER_MIRRORS = true;

  KEY = function(x, y) {
    return x + ',' + y;
  };

  COORDS = function(key) {
    var parts, x, y;
    parts = key.split(",");
    x = parseInt(parts[0]);
    y = parseInt(parts[1]);
    return [x, y];
  };

  mirrors = {
    leftmirror: {
      dx: 1,
      dy: 0
    },
    rightmirror: {
      dx: -1,
      dy: 0
    },
    upmirror: {
      dx: 0,
      dy: 1
    },
    downmirror: {
      dx: 0,
      dy: -1
    }
  };

  Level = (function() {

    function Level(game, opts) {
      this.game = game;
      if (opts == null) {
        opts = {};
      }
      this.addActor = opts.addActor;
      this.removeActor = opts.removeActor;
      this.cells = {};
      this.bgs = {};
      this.fgs = {};
      this.cellsByName = {};
      this.entities = {};
      this.mirrorSeers = [];
      console.time('generating floor of depth ' + opts.depth);
      this.generate(opts);
      console.timeEnd('generating floor of depth ' + opts.depth);
      this.ambientLight = [0, 0, 0];
      this.display = this.game.display;
    }

    Level.prototype.canMoveTo = function(x, y, opts) {
      var bump, cell, entities, key;
      if (opts == null) {
        opts = {};
      }
      key = KEY(x, y);
      cell = this.cells[KEY(x, y)];
      if (cell == null) {
        return false;
      }
      if (opts.entities) {
        entities = this.entitiesAtCell(x, y);
        if (opts.self) {
          if ((entities.length === 1 && entities[0] !== opts.self) || entities.length > 1) {
            return {
              canMove: false
            };
          }
        } else {
          if (entities.length === 0) {
            return {
              canMove: false
            };
          }
        }
      }
      if (cell.blocksMovement === false) {
        return {
          canMove: true
        };
      }
      bump = getBumpMessage(cell);
      return {
        canMove: false,
        bump: bump
      };
    };

    Level.prototype.allEntities = function() {
      var all, entityList, key, _ref;
      all = [];
      _ref = this.entities;
      for (key in _ref) {
        entityList = _ref[key];
        all = all.concat(entityList);
      }
      return all;
    };

    Level.prototype.entitiesAtCell = function(x, y) {
      return (this.entities[KEY(x, y)] || []).slice();
    };

    Level.prototype.hostilesAtCell = function(x, y) {
      var e;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this.entitiesAtCell(x, y);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          e = _ref[_i];
          if (e.hostile) {
            _results.push(e);
          }
        }
        return _results;
      }).call(this);
    };

    Level.prototype.switchLevel = function(delta) {
      return this.game.switchLevel(delta);
    };

    Level.prototype.findFreeCell = function(_arg) {
      var cellList, key, room, roomRect, type, x, y, _ref, _ref1, _ref2;
      _ref = _arg != null ? _arg : {}, type = _ref.type, room = _ref.room;
      if (type == null) {
        type = 'floor';
      }
      assert(typeof type === 'string');
      cellList = this.cellsByName[type];
      assert(cellList.length);
      roomRect = room != null ? Rect.fromRoom(room) : void 0;
      while (true) {
        key = cellList.random();
        if (roomRect != null) {
          _ref1 = COORDS(key), x = _ref1[0], y = _ref1[1];
          if (!roomRect.containsXY(x, y)) {
            continue;
          }
        }
        assert(this.cells[key] === cells[type]);
        if (!((_ref2 = this.entities[key]) != null ? _ref2.length : void 0)) {
          return COORDS(key);
        }
      }
    };

    Level.prototype.lock = function() {
      return this.game.lock();
    };

    Level.prototype.unlock = function() {
      return this.game.unlock();
    };

    Level.prototype.addStatus = function(statusMessage) {
      return this.game.addStatus(statusMessage);
    };

    Level.prototype.setCell = function(x, y, type) {
      var cell, cellList, i, key, oldCell;
      cell = cells[type];
      assert(cell, "unknown cell type '%s'".format(type.toString()));
      key = x + ',' + y;
      oldCell = this.cells[key];
      if (oldCell != null) {
        delete this.fgs[key];
        delete this.bgs[key];
        cellList = this.cellsByName[oldCell.name];
        i = cellList.indexOf(key);
        if (i !== -1) {
          cellList.splice(i, 1);
        }
      }
      this.cells[key] = cell;
      if (cell.bg != null) {
        this.bgs[key] = cell.bg.random();
      }
      if (cell.fg != null) {
        this.fgs[key] = cell.fg.random();
      }
      cellList = this.cellsByName[type];
      if (!cellList) {
        cellList = this.cellsByName[type] = [];
      }
      return cellList.push(key);
    };

    Level.prototype.generate = function(opts) {
      var WALLS_MIRRORED, endx, endy, height, i, mapInfo, startx, starty, width, x, y, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _results;
      if (true) {
        width = 60;
        height = ROT.DEFAULT_HEIGHT;
        mapInfo = this._generateDigger(width, height);
        this._placeEntities(mapInfo, opts);
      } else {
        _ref = [7, 23], startx = _ref[0], endx = _ref[1];
        _ref1 = [3, 13], starty = _ref1[0], endy = _ref1[1];
        WALLS_MIRRORED = true;
        for (y = _i = starty; starty <= endy ? _i <= endy : _i >= endy; y = starty <= endy ? ++_i : --_i) {
          for (x = _j = startx; startx <= endx ? _j <= endx : _j >= endx; x = startx <= endx ? ++_j : --_j) {
            this.setCell(x, y, 'floor');
          }
        }
        if (WALLS_MIRRORED) {
          for (y = _k = starty; starty <= endy ? _k <= endy : _k >= endy; y = starty <= endy ? ++_k : --_k) {
            this.setCell(endx + 1, y, 'leftmirror');
            this.setCell(startx - 1, y, 'rightmirror');
            void 0;
          }
          for (x = _l = startx; startx <= endx ? _l <= endx : _l >= endx; x = startx <= endx ? ++_l : --_l) {
            this.setCell(x, endy + 1, 'upmirror');
            this.setCell(x, starty - 1, 'downmirror');
            void 0;
          }
        }
      }
      this.recalcFov();
      _results = [];
      for (i = _m = 0; _m <= 9; i = ++_m) {
        _ref2 = this.findFreeCell(), x = _ref2[0], y = _ref2[1];
        _results.push(new Food(this, x, y));
      }
      return _results;
    };

    Level.prototype._generateDigger = function(width, height) {
      var digger, dx, dy, left, mirrorRoom, mirrorRoomRect, right, rooms, x, y, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3,
        _this = this;
      digger = new ROT.Map.Digger(width, height);
      digger.create(function(x, y, val) {
        if (val === 0) {
          return _this.setCell(x, y, 'floor');
        }
      });
      rooms = digger.getRooms();
      if (true) {
        mirrorRoom = rooms.random();
        mirrorRoomRect = Rect.fromRoom(mirrorRoom);
        y = mirrorRoomRect.y1 - 1;
        if (y > 0) {
          for (x = _i = _ref = mirrorRoomRect.x1, _ref1 = mirrorRoomRect.x2; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = _ref <= _ref1 ? ++_i : --_i) {
            if ((this.cells[x + ',' + y] == null) && (this.cells[x + ',' + (y - 1)] == null)) {
              this.setCell(x, y, 'downmirror');
            }
          }
        }
      }
      for (y = _j = 0; 0 <= height ? _j <= height : _j >= height; y = 0 <= height ? ++_j : --_j) {
        for (x = _k = 0; 0 <= width ? _k <= width : _k >= width; x = 0 <= width ? ++_k : --_k) {
          if (this.cells[x + ',' + y] == null) {
            left = this.cells[(x - 1) + ',' + y];
            right = this.cells[(x + 1) + '.' + y];
            _ref2 = ROT.DIRS['8'];
            for (_l = 0, _len = _ref2.length; _l < _len; _l++) {
              _ref3 = _ref2[_l], dx = _ref3[0], dy = _ref3[1];
              if (this.cells[(x + dx) + ',' + (y + dy)] === cells.floor) {
                this.setCell(x, y, 'plywood');
                break;
              }
            }
          }
        }
      }
      return digger;
    };

    Level.prototype._placeEntities = function(mapInfo, opts) {
      var entranceRoom, entranceRoomRect, exitRoom, exitRoomRect, i, otherRooms, r, rooms, x, y, _i, _ref, _ref1, _ref2, _ref3, _results;
      rooms = mapInfo.getRooms();
      exitRoom = rooms.random();
      exitRoomRect = Rect.fromRoom(exitRoom);
      _ref = this.findFreeCell({
        room: exitRoom
      }), x = _ref[0], y = _ref[1];
      this.downStairs = new DownStairs(this, x, y);
      otherRooms = ((function() {
        var _i, _len, _results;
        if (r !== exitRoom) {
          _results = [];
          for (_i = 0, _len = rooms.length; _i < _len; _i++) {
            r = rooms[_i];
            _results.push(r);
          }
          return _results;
        }
      })());
      otherRooms.sort(function(r1, r2) {
        var a, b;
        a = Point.distance(Rect.fromRoom(r1).center(), exitRoomRect.center());
        b = Point.distance(Rect.fromRoom(r2).center(), exitRoomRect.center());
        if (a >= b) {
          return -1;
        } else {
          return 1;
        }
      });
      entranceRoom = otherRooms[0] || exitRoom;
      entranceRoomRect = Rect.fromRoom(entranceRoom);
      _ref1 = this.findFreeCell({
        room: entranceRoom
      }), x = _ref1[0], y = _ref1[1];
      if (!opts.noUpStairs) {
        this.upStairs = new UpStairs(this, x, y);
      } else {
        this.upStairsPosition = [x, y];
      }
      _results = [];
      for (i = _i = 0; _i <= 4; i = ++_i) {
        _ref2 = this.findFreeCell(), x = _ref2[0], y = _ref2[1];
        while (entranceRoomRect.containsXY(x, y)) {
          _ref3 = this.findFreeCell(), x = _ref3[0], y = _ref3[1];
        }
        _results.push(new Monster(this, x, y));
      }
      return _results;
    };

    Level.prototype.entryPosition = function(delta) {
      var _ref;
      if (delta > 0) {
        return ((_ref = this.upStairs) != null ? _ref.position() : void 0) || this.upStairsPosition;
      } else {
        return this.downStairs.position();
      }
    };

    Level.prototype._lightPasses = function(x, y) {
      var _ref;
      return (_ref = this.cells[x + ',' + y]) != null ? _ref.lightPasses : void 0;
    };

    Level.prototype.createFOV = function() {
      var _this = this;
      return new ROT.FOV.DiscreteShadowcasting((function(x, y) {
        return _this._lightPasses(x, y);
      }), {
        topology: LIGHT_TOPOLOGY
      });
    };

    Level.prototype.recalcFov = function() {
      var _this = this;
      return this.fov = new ROT.FOV.PreciseShadowcasting((function(x, y) {
        return _this._lightPasses(x, y);
      }), {
        topology: LIGHT_TOPOLOGY
      });
    };

    Level.prototype.calcLightData = function() {
      var entity, entityList, key, lightData, lightInfo, lighting, reflectivity, _i, _len, _ref,
        _this = this;
      reflectivity = function(x, y) {
        var _ref;
        return ((_ref = _this.cells[x + ',' + y]) != null ? _ref.reflectivity : void 0) || 0;
      };
      lighting = new ROT.Lighting(reflectivity, {
        range: 12,
        passes: 2
      });
      lighting.setFOV(this.fov);
      _ref = this.entities;
      for (key in _ref) {
        entityList = _ref[key];
        for (_i = 0, _len = entityList.length; _i < _len; _i++) {
          entity = entityList[_i];
          lightInfo = entity.light;
          if (lightInfo) {
            lighting.setLight(entity.getX(), entity.getY(), lightInfo.color);
          }
        }
      }
      lightData = {};
      lighting.compute(function(x, y, color) {
        return lightData[x + ',' + y] = color;
      });
      return lightData;
    };

    Level.prototype.calcVisible = function() {
      var entity, _i, _len, _ref, _ref1, _results,
        _this = this;
      this.visible = {};
      if ((_ref = this.hasBeenVisible) == null) {
        this.hasBeenVisible = {};
      }
      this._visibleEntities = [];
      _ref1 = this.mirrorSeers;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        entity = _ref1[_i];
        _results.push(this.fov.compute(entity.getX(), entity.getY(), 12, function(x, y, radius, visibility) {
          var e, key, _j, _len1, _ref2, _results1;
          key = x + ',' + y;
          _this.visible[x + ',' + y] = visibility;
          _this.hasBeenVisible[x + ',' + y] = true;
          _ref2 = _this.entities[key] || [];
          _results1 = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            e = _ref2[_j];
            _results1.push(_this._visibleEntities.push({
              entity: e,
              distance: radius
            }));
          }
          return _results1;
        }));
      }
      return _results;
    };

    Level.prototype.visibleEntities = function() {
      return this._visibleEntities || [];
    };

    Level.prototype.moveEntity = function(entity, x, y) {
      var a, b, otherEntities, _i, _j, _len, _len1, _results;
      otherEntities = this.entitiesAtCell(x, y);
      for (_i = 0, _len = otherEntities.length; _i < _len; _i++) {
        a = otherEntities[_i];
        a.bump(entity);
      }
      this.removeEntity(entity, {
        removeActor: false
      });
      entity.setPosition(x, y);
      this.addEntity(entity, x, y, {
        addActor: false
      });
      otherEntities = this.entitiesAtCell(x, y);
      _results = [];
      for (_j = 0, _len1 = otherEntities.length; _j < _len1; _j++) {
        b = otherEntities[_j];
        if (b !== entity) {
          _results.push(b.afterBump(entity));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Level.prototype.removeEntity = function(entity, opts) {
      var e, entityList, found, i, x, y, _i, _len;
      if (opts == null) {
        opts = {};
      }
      x = entity.getX();
      y = entity.getY();
      entityList = this.entities[KEY(x, y)];
      assert(entityList);
      found = void 0;
      for (i = _i = 0, _len = entityList.length; _i < _len; i = ++_i) {
        e = entityList[i];
        if (e === entity) {
          found = entityList.splice(i, 1);
          assert(found[0] === e && e === entity);
          break;
        }
      }
      assert(found);
      if (opts.removeActor !== false && entity.act) {
        this.removeActor(entity);
        i = this.mirrorSeers.indexOf(entity);
        if (i !== -1) {
          return this.mirrorSeers.splice(i, 1);
        }
      }
    };

    Level.prototype.addEntity = function(entity, x, y, opts) {
      var entityList, key;
      if (opts == null) {
        opts = {};
      }
      key = KEY(x, y);
      entityList = this.entities[key];
      if (entityList == null) {
        entityList = this.entities[key] = [];
      }
      entityList.push(entity);
      if (opts.addActor !== false && entity.act) {
        this.addActor(entity);
        if (entity.seesMirrors) {
          return this.mirrorSeers.push(entity);
        }
      }
    };

    Level.prototype.wakeUpActors = function() {
      var entity, _i, _len, _ref, _results;
      _ref = this.allEntities();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        if (entity.act) {
          _results.push(this.addActor(entity));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Level.prototype.draw = function() {
      var add, args, baseColor, bg, camRect, cell, cellKey, cellList, ch, character, delta, drawx, drawy, dx, dy, dynamicLight, e, entityColor, entityList, fg, finalColor, fog, intensity, key, light, lightColor, lightData, maxheight, maxwidth, mirrorType, mirrorx, mirrory, multiply, planeBreak, rayX, rayXDelta, rayY, rayYDelta, screenKey, screenX, screenY, topEntity, x, xDelta, y, yDelta, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      this.display.clear();
      if ((_ref = this.fog) == null) {
        this.fog = {};
      }
      lightData = this.calcLightData();
      this.calcVisible();
      add = ROT.Color.add;
      multiply = ROT.Color.multiply;
      baseColor = null;
      camRect = this.camera.getRect();
      for (y = _i = _ref1 = camRect.y1, _ref2 = camRect.y2; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; y = _ref1 <= _ref2 ? ++_i : --_i) {
        for (x = _j = _ref3 = camRect.x1, _ref4 = camRect.x2; _ref3 <= _ref4 ? _j <= _ref4 : _j >= _ref4; x = _ref3 <= _ref4 ? ++_j : --_j) {
          screenX = x - camRect.x1;
          screenY = y - camRect.y1;
          key = x + ',' + y;
          cell = this.cells[key];
          if (cell == null) {
            continue;
          }
          _ref5 = COORDS(key), x = _ref5[0], y = _ref5[1];
          baseColor = this.fgs[key] || [255, 255, 255];
          light = lightData[key];
          fog = this.fog[key] || 0;
          if (light) {
            intensity = light[0];
            if (fog < intensity) {
              fog = Math.min(70, intensity);
              this.fog[key] = fog;
            }
          }
          if (!light || (light && fog >= (light[0] || 0))) {
            light = [fog, fog, fog];
          }
          if (light == null) {
            light = this.ambientLight;
          }
          dynamicLight = lightData[key];
          if (dynamicLight != null) {
            light = clampColor(add(light, dynamicLight));
          }
          finalColor = multiply(baseColor, light);
          lightColor = finalColor;
          entityList = this.entities[key];
          if (this.visible[key] == null) {
            entityList = (function() {
              var _k, _len, _ref6, _results;
              _ref6 = entityList || [];
              _results = [];
              for (_k = 0, _len = _ref6.length; _k < _len; _k++) {
                e = _ref6[_k];
                if (e.seeInFog) {
                  _results.push(e);
                }
              }
              return _results;
            })();
          }
          bg = null;
          if (entityList != null ? entityList.length : void 0) {
            topEntity = entityList[entityList.length - 1];
            character = topEntity.char;
            assert(character, "entity doesn't define .char");
            entityColor = topEntity.color;
            if (entityColor != null) {
              if (typeof entityColor === 'string') {
                entityColor = ROT.Color.fromString(entityColor);
              }
              finalColor = multiply(finalColor, entityColor);
            }
          } else {
            character = cell.char;
            bg = this.bgs[key] || null;
            if (bg) {
              bg = ROT.Color.toRGB(multiply(bg, light));
            }
          }
          this.display.draw(screenX, screenY, character, ROT.Color.toRGB(finalColor), bg || null);
        }
      }
      maxwidth = this.display._options.width;
      maxheight = this.display._options.height;
      if (RENDER_MIRRORS) {
        for (mirrorType in mirrors) {
          delta = mirrors[mirrorType];
          cellList = this.cellsByName[mirrorType] || [];
          for (_k = 0, _len = cellList.length; _k < _len; _k++) {
            key = cellList[_k];
            if (!this.visible[key]) {
              continue;
            }
            _ref6 = COORDS(key), mirrorx = _ref6[0], mirrory = _ref6[1];
            xDelta = delta.dx;
            yDelta = delta.dy;
            rayXDelta = xDelta;
            rayYDelta = yDelta;
            planeBreak = false;
            _ref7 = this.mirrorSeers;
            for (_l = 0, _len1 = _ref7.length; _l < _len1; _l++) {
              e = _ref7[_l];
              if ((xDelta && Math.sign(e.getX() - mirrorx) === xDelta) || (yDelta && Math.sign(e.getY() - mirrory) === yDelta)) {
                planeBreak = true;
                break;
              }
            }
            if (planeBreak) {
              continue;
            }
            dx = 0;
            dy = 0;
            rayX = 0;
            rayY = 0;
            while (true) {
              dx += xDelta;
              dy += yDelta;
              rayX += rayXDelta;
              rayY += rayYDelta;
              cellKey = (mirrorx - rayX) + ',' + (mirrory - rayY);
              if (!this.cells[cellKey]) {
                break;
              }
              screenKey = this.camera.getScreenKey(mirrorx - rayX, mirrory - rayY);
              args = this.display._data[screenKey];
              if (args == null) {
                break;
              }
              _ref8 = this.camera.getScreenCoords(mirrorx + dx, mirrory + dy), drawx = _ref8[0], drawy = _ref8[1];
              if (drawx >= this.camera.width || drawy >= this.camera.height || drawx < 0 || drawy < 0) {
                break;
              }
              x = args[0], y = args[1], ch = args[2], fg = args[3], bg = args[4];
              cell = this.cells[this.camera.getWorldKey(x, y)];
              this.display.draw(drawx, drawy, ch, fg, bg);
              if ((rayXDelta < 0 && cell === cells.rightmirror) || (rayXDelta > 0 && cell === cells.leftmirror)) {
                rayXDelta = -rayXDelta;
              }
              if ((rayYDelta < 0 && cell === cells.downmirror) || (rayYDelta > 0 && cell === cells.upmirror)) {
                rayYDelta = -rayYDelta;
              }
            }
          }
        }
      }
      return void 0;
    };

    Level.prototype.setCamera = function(camera) {
      this.camera = camera;
    };

    return Level;

  })();

  window.Level = Level;

  Camera = (function() {

    function Camera(entity, width, height) {
      this.entity = entity;
      this.width = width;
      this.height = height;
      this.getRect();
    }

    Camera.prototype.getScreenCoords = function(x, y) {
      return [x - this.rect.x1, y - this.rect.y1];
    };

    Camera.prototype.getScreenKey = function(x, y) {
      return (x - this.rect.x1) + ',' + (y - this.rect.y1);
    };

    Camera.prototype.getWorldKey = function(x, y) {
      return (x + this.rect.x1) + ',' + (y + this.rect.y1);
    };

    Camera.prototype.getRect = function() {
      var x, y, _ref;
      _ref = [this.entity.getX() - Math.floor(this.width / 2), this.entity.getY() - Math.floor(this.height / 2)], x = _ref[0], y = _ref[1];
      return this.rect = Rect.fromWH(x, y, this.width, this.height);
    };

    return Camera;

  })();

  window.Camera = Camera;

}).call(this);
