//@ sourceMappingURL=level.map
// Generated by CoffeeScript 1.6.1
(function() {
  var Camera, KEY, LIGHT_TOPOLOGY, Level, RENDER_MIRRORS, mirrors;

  LIGHT_TOPOLOGY = 8;

  RENDER_MIRRORS = true;

  KEY = function(x, y) {
    return x + ',' + y;
  };

  window.COORDS = function(key) {
    var parts, x, y;
    parts = key.split(",");
    x = parseInt(parts[0]);
    y = parseInt(parts[1]);
    return [x, y];
  };

  mirrors = {
    leftmirror: {
      dx: 1,
      dy: 0
    },
    rightmirror: {
      dx: -1,
      dy: 0
    },
    upmirror: {
      dx: 0,
      dy: 1
    },
    downmirror: {
      dx: 0,
      dy: -1
    }
  };

  Level = (function() {

    function Level(game, opts) {
      this.game = game;
      if (opts == null) {
        opts = {};
      }
      this.addActor = opts.addActor;
      this.removeActor = opts.removeActor;
      this.cells = {};
      this.closedDoors = {};
      this.bgs = {};
      this.fgs = {};
      this.depth = opts.depth;
      this.cellsByName = {};
      this.entities = {};
      this.mirrorSeers = [];
      this.generate(opts);
      this.ambientLight = [0, 0, 0];
      this.display = this.game.display;
    }

    Level.prototype.canMoveTo = function(x, y, opts) {
      var cell, e, entities, key;
      if (opts == null) {
        opts = {};
      }
      key = KEY(x, y);
      cell = this.cells[KEY(x, y)];
      if (cell == null) {
        return {
          canMove: false
        };
      }
      if (opts.entities) {
        entities = (function() {
          var _i, _len, _ref, _results;
          _ref = this.entitiesAtCell(x, y);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            e = _ref[_i];
            if (!(e.blocksPathFinding === false)) {
              _results.push(e);
            }
          }
          return _results;
        }).call(this);
        if ((entities.length === 1 && entities[0] !== opts.self) || entities.length > 1) {
          return {
            canMove: false
          };
        }
      }
      if (cell.blocksMovement === false) {
        return {
          canMove: true
        };
      }
      return {
        canMove: false,
        bump: getBumpMessage(cell),
        bumpFunc: cell.bumpFunc
      };
    };

    Level.prototype.allEntities = function() {
      var all, entityList, key, _ref;
      all = [];
      _ref = this.entities;
      for (key in _ref) {
        entityList = _ref[key];
        all = all.concat(entityList);
      }
      return all;
    };

    Level.prototype.entitiesAtCell = function(x, y) {
      return (this.entities[KEY(x, y)] || []).slice();
    };

    Level.prototype.hostilesAtCell = function(x, y) {
      var e;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = this.entitiesAtCell(x, y);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          e = _ref[_i];
          if (e.hostile) {
            _results.push(e);
          }
        }
        return _results;
      }).call(this);
    };

    Level.prototype.switchLevel = function(delta) {
      return this.game.switchLevel(delta);
    };

    Level.prototype.findFreeCell = function(_arg) {
      var cellList, key, room, roomRect, type, x, y, _ref, _ref1, _ref2;
      _ref = _arg != null ? _arg : {}, type = _ref.type, room = _ref.room;
      if (type == null) {
        type = 'floor';
      }
      assert(typeof type === 'string');
      cellList = this.cellsByName[type];
      assert(cellList.length);
      roomRect = room != null ? Rect.fromRoom(room) : void 0;
      while (true) {
        key = cellList.random();
        _ref1 = COORDS(key), x = _ref1[0], y = _ref1[1];
        if (roomRect != null) {
          if (!roomRect.containsXY(x, y)) {
            continue;
          }
        }
        assert(this.cells[key] === cells[type]);
        if (!((_ref2 = this.entities[key]) != null ? _ref2.length : void 0)) {
          return [x, y];
        }
      }
    };

    Level.prototype.lock = function() {
      return this.game.lock();
    };

    Level.prototype.unlock = function() {
      return this.game.unlock();
    };

    Level.prototype.addStatus = function(statusMessage) {
      return this.game.addStatus(statusMessage);
    };

    Level.prototype.setCell = function(x, y, type) {
      var cell, cellList, i, key, oldCell;
      cell = cells[type];
      assert(cell, "unknown cell type '%s'".format(type.toString()));
      key = x + ',' + y;
      oldCell = this.cells[key];
      if (oldCell != null) {
        delete this.fgs[key];
        delete this.bgs[key];
        cellList = this.cellsByName[oldCell.name];
        i = cellList.indexOf(key);
        if (i !== -1) {
          cellList.splice(i, 1);
        }
      }
      this.cells[key] = cell;
      if (cell.bg != null) {
        this.bgs[key] = cell.bg.random();
      }
      if (cell.fg != null) {
        this.fgs[key] = cell.fg.random();
      }
      cellList = this.cellsByName[type];
      if (!cellList) {
        cellList = this.cellsByName[type] = [];
      }
      return cellList.push(key);
    };

    Level.prototype.generate = function(opts) {
      var mapInfo;
      opts.numMonsters = Math.floor(this.depth * 2.5);
      opts.numFood = Math.floor(this.depth * 2.4);
      opts.numShells = Math.floor(this.depth);
      mapInfo = this._generateDigger();
      this._placeEntities(mapInfo, opts);
      return this.recalcFov();
    };

    Level.prototype._generateDigger = function(opts) {
      var constructor, didMaze, digger, dx, dy, left, mapOpts, mirrorRoom, mirrorRoomRect, n, rect, right, room, roomInfo, roomInfos, rooms, walls, x, x1, x2, y, y1, y2, _i, _j, _k, _l, _len, _len1, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
        _this = this;
      this.width = Math.floor(50 + (this.depth - 1) * 2.9);
      this.height = Math.floor(20 + (this.depth - 1) * 2.7);
      this.roomDugPercentage = Math.min(1, .1 + this.depth * .1);
      this.roomRange = [[4, Math.floor(12 + this.depth / 3.2)], [3, Math.floor(10 + this.depth / 3.2)]];
      mapOpts = {
        roomWidth: this.roomRange[0],
        roomHeight: this.roomRange[1],
        timeLimit: Infinity
      };
      if (true) {
        constructor = ROT.Map.Uniform;
        mapOpts.roomDugPercentage = this.roomDugPercentage;
      } else {
        constructor = ROT.Map.Digger;
        mapOpts.dugPercentage = this.roomDugPercentage;
      }
      digger = new constructor(this.width, this.height, mapOpts);
      digger.create(function(x, y, val) {
        if (val === 0) {
          return _this.setCell(x, y, 'floor');
        }
      });
      rooms = digger.getRooms();
      roomInfos = [];
      this.roomInfos = roomInfos;
      didMaze = false;
      for (n = _i = 0, _len = rooms.length; _i < _len; n = ++_i) {
        room = rooms[n];
        rect = Rect.fromRoom(room);
        roomInfo = {
          room: room,
          rect: rect,
          area: rect.area()
        };
        roomInfos.push(roomInfo);
        if (roomInfo.area > 80 && !didMaze) {
          window.mazeRoom = roomInfo;
          this._generateRoomMaze(roomInfo, opts);
          didMaze = true;
        }
      }
      if (true) {
        for (n = _j = 0, _ref = Math.floor(ROT.RNG.getUniform() * 4); 0 <= _ref ? _j <= _ref : _j >= _ref; n = 0 <= _ref ? ++_j : --_j) {
          mirrorRoom = rooms.random();
          mirrorRoomRect = Rect.fromRoom(mirrorRoom);
          x1 = mirrorRoomRect.x1 - 1;
          x2 = mirrorRoomRect.x2 + 1;
          y1 = mirrorRoomRect.y1 - 1;
          y2 = mirrorRoomRect.y2 + 1;
          walls = [
            function() {
              var x, _k, _ref1, _ref2, _results;
              _results = [];
              for (x = _k = _ref1 = mirrorRoomRect.x1, _ref2 = mirrorRoomRect.x2; _ref1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; x = _ref1 <= _ref2 ? ++_k : --_k) {
                if ((_this.cells[x + ',' + y1] == null) && (_this.cells[x + ',' + (y1 - 1)] == null)) {
                  _results.push(_this.setCell(x, y1, 'downmirror'));
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            }, function() {
              var x, _k, _ref1, _ref2, _results;
              _results = [];
              for (x = _k = _ref1 = mirrorRoomRect.x1, _ref2 = mirrorRoomRect.x2; _ref1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; x = _ref1 <= _ref2 ? ++_k : --_k) {
                if ((_this.cells[x + ',' + y2] == null) && (_this.cells[x + ',' + (y2 + 1)] == null)) {
                  _results.push(_this.setCell(x, y2, 'upmirror'));
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            }, function() {
              var y, _k, _ref1, _ref2, _results;
              _results = [];
              for (y = _k = _ref1 = mirrorRoomRect.y1, _ref2 = mirrorRoomRect.y2; _ref1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; y = _ref1 <= _ref2 ? ++_k : --_k) {
                if ((_this.cells[x1 + ',' + y] == null) && (_this.cells[(x1 - 1) + ',' + y] == null)) {
                  _results.push(_this.setCell(x1, y, 'rightmirror'));
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            }, function() {
              var y, _k, _ref1, _ref2, _results;
              _results = [];
              for (y = _k = _ref1 = mirrorRoomRect.y1, _ref2 = mirrorRoomRect.y2; _ref1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; y = _ref1 <= _ref2 ? ++_k : --_k) {
                if ((_this.cells[x2 + ',' + y] == null) && (_this.cells[(x2 + 1) + ',' + y] == null)) {
                  _results.push(_this.setCell(x2, y, 'leftmirror'));
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            }
          ];
          walls = walls.randomize();
          for (n = _k = 0, _ref1 = Math.floor(ROT.RNG.getUniform() * walls.length); 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; n = 0 <= _ref1 ? ++_k : --_k) {
            walls[n]();
          }
        }
      }
      if (true) {
        for (y = _l = 0, _ref2 = this.height; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; y = 0 <= _ref2 ? ++_l : --_l) {
          for (x = _m = 0, _ref3 = this.width; 0 <= _ref3 ? _m <= _ref3 : _m >= _ref3; x = 0 <= _ref3 ? ++_m : --_m) {
            if (this.cells[x + ',' + y] == null) {
              left = this.cells[(x - 1) + ',' + y];
              right = this.cells[(x + 1) + '.' + y];
              _ref4 = ROT.DIRS['8'];
              for (_n = 0, _len1 = _ref4.length; _n < _len1; _n++) {
                _ref5 = _ref4[_n], dx = _ref5[0], dy = _ref5[1];
                if (this.cells[(x + dx) + ',' + (y + dy)] === cells.floor) {
                  this.setCell(x, y, 'plywood');
                  break;
                }
              }
            }
          }
        }
      }
      return digger;
    };

    Level.prototype._generateRoomMaze = function(roomInfo, opts) {
      var maze, rect,
        _this = this;
      rect = roomInfo.rect;
      maze = new ROT.Map.IceyMaze(rect.width() + 1, rect.height() + 1, 0);
      maze.create(function(x, y, val) {
        x = x + rect.x1;
        y = y + rect.y1;
        if (val !== 0) {
          return _this.setCell(x, y, 'plywood');
        }
      });
      return roomInfo.room.getDoors(function(x, y) {
        var i, j, _i, _ref, _ref1, _results;
        _results = [];
        for (j = _i = _ref = y - 1, _ref1 = y + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; j = _ref <= _ref1 ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref2, _ref3, _results1;
            _results1 = [];
            for (i = _j = _ref2 = x - 1, _ref3 = x + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; i = _ref2 <= _ref3 ? ++_j : --_j) {
              _results1.push(this.setCell(i, j, 'floor'));
            }
            return _results1;
          }).call(_this));
        }
        return _results;
      });
    };

    Level.prototype._generateMaze = function(width, height) {
      var maze,
        _this = this;
      maze = new ROT.Map.EllerMaze(width, height);
      maze.create(function(x, y, val) {
        if (val === 0) {
          return _this.setCell(x, y, 'floor');
        } else {
          return _this.setCell(x, y, 'fourmirror');
        }
      });
      return {
        getRooms: function() {
          return [new ROT.Map.Feature.Room(0, 0, width, height)];
        }
      };
    };

    Level.prototype._generateRoom = function(width, height) {
      var floorType, wallType, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      wallType = 'plywood';
      floorType = 'floor';
      for (x = _i = 0, _ref = width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.setCell(x, 0, wallType);
        this.setCell(x, height - 1, wallType);
      }
      for (y = _j = 0, _ref1 = height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
        this.setCell(0, y, wallType);
        this.setCell(width - 1, y, wallType);
      }
      for (y = _k = 1, _ref2 = height - 2; 1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; y = 1 <= _ref2 ? ++_k : --_k) {
        for (x = _l = 1, _ref3 = width - 2; 1 <= _ref3 ? _l <= _ref3 : _l >= _ref3; x = 1 <= _ref3 ? ++_l : --_l) {
          this.setCell(x, y, floorType);
        }
      }
      return {
        getRooms: function() {
          return [new ROT.Map.Feature.Room(0, 0, width, height)];
        }
      };
    };

    Level.prototype._placeEntities = function(mapInfo, opts) {
      var doorCount, entranceRoom, entranceRoomRect, exitRoom, exitRoomRect, failsafe, i, iswall, otherRooms, r, room, roomInfo, rooms, roomsByDoorCount, x, y, _i, _j, _k, _l, _len, _len1, _m, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results,
        _this = this;
      rooms = mapInfo.getRooms();
      exitRoom = rooms.random();
      exitRoomRect = Rect.fromRoom(exitRoom);
      _ref = this.findFreeCell({
        room: exitRoom
      }), x = _ref[0], y = _ref[1];
      this.downStairs = new DownStairs(this, x, y);
      otherRooms = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = rooms.length; _i < _len; _i++) {
          r = rooms[_i];
          if (r !== exitRoom) {
            _results.push(r);
          }
        }
        return _results;
      })();
      if (otherRooms.length) {
        otherRooms.sort(function(r1, r2) {
          var a, b;
          a = Point.distance(Rect.fromRoom(r1).center(), exitRoomRect.center());
          b = Point.distance(Rect.fromRoom(r2).center(), exitRoomRect.center());
          if (a >= b) {
            return -1;
          } else {
            return 1;
          }
        });
      }
      entranceRoom = otherRooms[0] || exitRoom;
      entranceRoomRect = Rect.fromRoom(entranceRoom);
      _ref1 = this.findFreeCell({
        room: entranceRoom
      }), x = _ref1[0], y = _ref1[1];
      if (!opts.noUpStairs) {
        this.upStairs = new UpStairs(this, x, y);
      } else {
        this.upStairsPosition = [x, y];
      }
      if (rooms.length > 1) {
        rooms = rooms.slice();
        roomsByDoorCount = {};
        for (_i = 0, _len = rooms.length; _i < _len; _i++) {
          room = rooms[_i];
          doorCount = 0;
          room.getDoors(function(x, y) {
            return doorCount += 1;
          });
          if ((_ref2 = roomsByDoorCount[doorCount]) == null) {
            roomsByDoorCount[doorCount] = [];
          }
          roomsByDoorCount[doorCount].push(room);
        }
      }
      if (true) {
        iswall = function(x, y) {
          var cell;
          cell = this.cells[KEY(x, y)];
          return !cell || !(cell.blocksMovement === false);
        };
        _ref3 = this.roomInfos;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          roomInfo = _ref3[_j];
          roomInfo.room.getDoors(function(x, y) {
            if ((iswall(x - 1, y) && iswall(x + 1, y)) || (iswall(x, y - 1) && iswall(x, y + 1))) {
              return new Door(_this, x, y);
            }
          });
        }
        for (i = _k = 0, _ref4 = opts.numMonsters - 1; 0 <= _ref4 ? _k <= _ref4 : _k >= _ref4; i = 0 <= _ref4 ? ++_k : --_k) {
          _ref5 = this.findFreeCell(), x = _ref5[0], y = _ref5[1];
          if (entranceRoom !== exitRoom) {
            failsafe = 0;
            while (entranceRoomRect.containsXY(x, y)) {
              assert((failsafe += 1) < 100);
              _ref6 = this.findFreeCell(), x = _ref6[0], y = _ref6[1];
            }
          }
          new Monster(this, x, y);
        }
        for (i = _l = 0, _ref7 = opts.numFood - 1; 0 <= _ref7 ? _l <= _ref7 : _l >= _ref7; i = 0 <= _ref7 ? ++_l : --_l) {
          _ref8 = this.findFreeCell(), x = _ref8[0], y = _ref8[1];
          new Food(this, x, y);
        }
        _results = [];
        for (i = _m = 0, _ref9 = opts.numShells - 1; 0 <= _ref9 ? _m <= _ref9 : _m >= _ref9; i = 0 <= _ref9 ? ++_m : --_m) {
          _ref10 = this.findFreeCell(), x = _ref10[0], y = _ref10[1];
          _results.push(new WhelkShell(this, x, y));
        }
        return _results;
      }
    };

    Level.prototype.entryPosition = function(delta) {
      var _ref;
      if (delta > 0) {
        return ((_ref = this.upStairs) != null ? _ref.position() : void 0) || this.upStairsPosition;
      } else {
        return this.downStairs.position();
      }
    };

    Level.prototype._lightPasses = function(x, y) {
      var key, _ref;
      key = x + ',' + y;
      if ((_ref = this.cells[key]) != null ? _ref.lightPasses : void 0) {
        if (!this.closedDoors[key]) {
          return true;
        }
      }
    };

    Level.prototype.createFOV = function() {
      var _this = this;
      return new ROT.FOV.DiscreteShadowcasting((function(x, y) {
        return _this._lightPasses(x, y);
      }), {
        topology: LIGHT_TOPOLOGY
      });
    };

    Level.prototype.recalcFov = function() {
      var _this = this;
      return this.fov = new ROT.FOV.PreciseShadowcasting((function(x, y) {
        return _this._lightPasses(x, y);
      }), {
        topology: LIGHT_TOPOLOGY
      });
    };

    Level.prototype.calcLightData = function() {
      var entity, entityList, key, lightData, lightInfo, lighting, reflectivity, _i, _len, _ref,
        _this = this;
      reflectivity = function(x, y) {
        var _ref;
        return ((_ref = _this.cells[x + ',' + y]) != null ? _ref.reflectivity : void 0) || 0;
      };
      lighting = new ROT.Lighting(reflectivity, {
        range: constants.playerSightRadius,
        passes: constants.lightPasses
      });
      lighting.setFOV(this.fov);
      _ref = this.entities;
      for (key in _ref) {
        entityList = _ref[key];
        for (_i = 0, _len = entityList.length; _i < _len; _i++) {
          entity = entityList[_i];
          lightInfo = entity.light;
          if (lightInfo) {
            lighting.setLight(entity.getX(), entity.getY(), lightInfo.color);
          }
        }
      }
      lightData = {};
      lighting.compute(function(x, y, color) {
        return lightData[x + ',' + y] = color;
      });
      return lightData;
    };

    Level.prototype.calcVisible = function() {
      var entity, _i, _len, _ref, _ref1,
        _this = this;
      this.visible = {};
      if ((_ref = this.hasBeenVisible) == null) {
        this.hasBeenVisible = {};
      }
      this._visibleEntities = [];
      _ref1 = this.mirrorSeers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        entity = _ref1[_i];
        this.fov.compute(entity.getX(), entity.getY(), constants.playerSightRadius, function(x, y, radius, visibility) {
          var e, key, _j, _len1, _ref2, _results;
          key = x + ',' + y;
          _this.visible[x + ',' + y] = visibility;
          _this.hasBeenVisible[x + ',' + y] = true;
          _ref2 = _this.entities[key] || [];
          _results = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            e = _ref2[_j];
            _results.push(_this._visibleEntities.push({
              entity: e,
              distance: radius
            }));
          }
          return _results;
        });
      }
      return void 0;
    };

    Level.prototype.visibleEntities = function() {
      return this._visibleEntities || [];
    };

    Level.prototype.awardXp = function(opts) {
      var player, _i, _len, _ref;
      _ref = this.mirrorSeers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.awardXp) {
          player.awardXp(opts);
        }
      }
      return void 0;
    };

    Level.prototype.addEntity = function(entity, x, y, opts) {
      var b, entityList, key, otherEntity, _i, _j, _len, _len1, _ref, _ref1;
      if (opts == null) {
        opts = {};
      }
      assert(entity.getX() === x);
      assert(entity.getY() === y);
      key = KEY(x, y);
      entityList = this.entities[key];
      if (entityList == null) {
        entityList = this.entities[key] = [];
      }
      entityList.push(entity);
      if (opts.addActor !== false && entity.act) {
        this.addActor(entity);
        if (entity.seesMirrors) {
          this.mirrorSeers.push(entity);
        }
      }
      if (!opts.skipBump) {
        _ref = entityList.slice();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          otherEntity = _ref[_i];
          if (otherEntity !== entity) {
            entity.bump(otherEntity, opts);
            otherEntity.bump(entity, opts);
          }
        }
        _ref1 = entityList.slice();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          b = _ref1[_j];
          if (b !== entity) {
            b.afterBump(entity, opts);
            entity.afterBump(b, opts);
          }
        }
      }
      return void 0;
    };

    Level.prototype.moveEntity = function(entity, x, y) {
      this.removeEntity(entity, {
        removeActor: false
      });
      entity.setPosition(x, y);
      return this.addEntity(entity, x, y, {
        addActor: false
      });
    };

    Level.prototype.removeEntity = function(entity, opts) {
      var e, entityList, found, i, x, y, _i, _len;
      if (opts == null) {
        opts = {};
      }
      x = entity.getX();
      y = entity.getY();
      entityList = this.entities[KEY(x, y)];
      assert(entityList);
      found = void 0;
      for (i = _i = 0, _len = entityList.length; _i < _len; i = ++_i) {
        e = entityList[i];
        if (e === entity) {
          found = entityList.splice(i, 1);
          if (entityList.length === 1 && entityList[0] instanceof Door) {
            entityList[0].close();
          }
          assert(found[0] === e && e === entity);
          break;
        }
      }
      assert(found);
      if (opts.removeActor !== false && entity.act) {
        this.removeActor(entity);
        i = this.mirrorSeers.indexOf(entity);
        if (i !== -1) {
          return this.mirrorSeers.splice(i, 1);
        }
      }
    };

    Level.prototype.wakeUpActors = function() {
      var entity, _i, _len, _ref;
      _ref = this.allEntities();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        if (entity.act) {
          this.addActor(entity);
        }
      }
      return void 0;
    };

    Level.prototype.draw = function() {
      var add, args, baseColor, bg, camRect, cell, cellKey, cellList, ch, character, delta, drawx, drawy, dx, dy, dynamicLight, e, entityBgColor, entityColor, entityList, fg, finalColor, fog, intensity, key, light, lightColor, lightData, maxheight, maxwidth, mirrorType, mirrorx, mirrory, multiply, opts, planeBreak, rayX, rayXDelta, rayY, rayYDelta, screenKey, screenX, screenY, topEntity, x, xDelta, y, yDelta, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      this.display.clear();
      if ((_ref = this.fog) == null) {
        this.fog = {};
      }
      lightData = this.calcLightData();
      this.calcVisible();
      add = ROT.Color.add;
      multiply = ROT.Color.multiply;
      baseColor = null;
      camRect = this.camera.getRect();
      for (y = _i = _ref1 = camRect.y1, _ref2 = camRect.y2; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; y = _ref1 <= _ref2 ? ++_i : --_i) {
        for (x = _j = _ref3 = camRect.x1, _ref4 = camRect.x2; _ref3 <= _ref4 ? _j <= _ref4 : _j >= _ref4; x = _ref3 <= _ref4 ? ++_j : --_j) {
          screenX = x - camRect.x1;
          screenY = y - camRect.y1;
          key = x + ',' + y;
          cell = this.cells[key];
          if (cell == null) {
            continue;
          }
          _ref5 = COORDS(key), x = _ref5[0], y = _ref5[1];
          baseColor = this.fgs[key] || [255, 255, 255];
          light = lightData[key];
          fog = this.fog[key] || 0;
          if (light) {
            intensity = light[0];
            if (fog < intensity) {
              fog = Math.min(70, intensity);
              this.fog[key] = fog;
            }
          }
          if (!light || (light && fog >= (light[0] || 0))) {
            light = [fog, fog, fog];
          }
          if (light == null) {
            light = this.ambientLight;
          }
          dynamicLight = lightData[key];
          if (dynamicLight != null) {
            light = clampColor(add(light, dynamicLight));
          }
          finalColor = multiply(baseColor, light);
          lightColor = finalColor;
          entityList = this.entities[key];
          if (this.visible[key] == null) {
            entityList = (function() {
              var _k, _len, _ref6, _results;
              _ref6 = entityList || [];
              _results = [];
              for (_k = 0, _len = _ref6.length; _k < _len; _k++) {
                e = _ref6[_k];
                if (e.seeInFog) {
                  _results.push(e);
                }
              }
              return _results;
            })();
          }
          bg = null;
          opts = void 0;
          if (entityList != null ? entityList.length : void 0) {
            topEntity = entityList[entityList.length - 1];
            character = topEntity.charFunc(x, y);
            opts = topEntity.drawOpts ? topEntity.drawOpts() : void 0;
            entityColor = topEntity.color;
            if (entityColor != null) {
              if (typeof entityColor === 'string') {
                entityColor = ROT.Color.fromString(entityColor);
              }
              finalColor = multiply(finalColor, entityColor);
            }
            if ((entityBgColor = topEntity.bg) != null) {
              if (typeof entityBgColor === 'string') {
                entityBgColor = ROT.Color.fromString(entityBgColor);
              }
              bg = entityBgColor;
            }
          } else {
            character = cell.char;
            bg = this.bgs[key] || null;
          }
          if (bg) {
            bg = ROT.Color.toRGB(multiply(bg, light));
          }
          this.display.draw(screenX, screenY, character, ROT.Color.toRGB(finalColor), bg || null, opts);
        }
      }
      maxwidth = this.display._options.width;
      maxheight = this.display._options.height;
      if (RENDER_MIRRORS) {
        for (mirrorType in mirrors) {
          delta = mirrors[mirrorType];
          cellList = this.cellsByName[mirrorType] || [];
          for (_k = 0, _len = cellList.length; _k < _len; _k++) {
            key = cellList[_k];
            if (!this.visible[key]) {
              continue;
            }
            _ref6 = COORDS(key), mirrorx = _ref6[0], mirrory = _ref6[1];
            xDelta = delta.dx;
            yDelta = delta.dy;
            rayXDelta = xDelta;
            rayYDelta = yDelta;
            planeBreak = false;
            _ref7 = this.mirrorSeers;
            for (_l = 0, _len1 = _ref7.length; _l < _len1; _l++) {
              e = _ref7[_l];
              if ((xDelta && Math.sign(e.getX() - mirrorx) === xDelta) || (yDelta && Math.sign(e.getY() - mirrory) === yDelta)) {
                planeBreak = true;
                break;
              }
            }
            if (planeBreak) {
              continue;
            }
            dx = 0;
            dy = 0;
            rayX = 0;
            rayY = 0;
            while (true) {
              dx += xDelta;
              dy += yDelta;
              rayX += rayXDelta;
              rayY += rayYDelta;
              cellKey = (mirrorx - rayX) + ',' + (mirrory - rayY);
              if (!this.cells[cellKey]) {
                break;
              }
              screenKey = this.camera.getScreenKey(mirrorx - rayX, mirrory - rayY);
              args = this.display._data[screenKey];
              if (args == null) {
                break;
              }
              _ref8 = this.camera.getScreenCoords(mirrorx + dx, mirrory + dy), drawx = _ref8[0], drawy = _ref8[1];
              if (drawx >= this.camera.width || drawy >= this.camera.height || drawx < 0 || drawy < 0) {
                break;
              }
              x = args[0], y = args[1], ch = args[2], fg = args[3], bg = args[4];
              cell = this.cells[this.camera.getWorldKey(x, y)];
              this.display.draw(drawx, drawy, ch, fg, bg);
              if ((rayXDelta < 0 && cell === cells.rightmirror) || (rayXDelta > 0 && cell === cells.leftmirror)) {
                rayXDelta = -rayXDelta;
              }
              if ((rayYDelta < 0 && cell === cells.downmirror) || (rayYDelta > 0 && cell === cells.upmirror)) {
                rayYDelta = -rayYDelta;
              }
            }
          }
        }
      }
      return void 0;
    };

    Level.prototype.setCamera = function(camera) {
      this.camera = camera;
    };

    return Level;

  })();

  window.Level = Level;

  Camera = (function() {

    function Camera(entity, width, height) {
      this.entity = entity;
      this.width = width;
      this.height = height;
      this.getRect();
    }

    Camera.prototype.getScreenCoords = function(x, y) {
      return [x - this.rect.x1, y - this.rect.y1];
    };

    Camera.prototype.getScreenKey = function(x, y) {
      return (x - this.rect.x1) + ',' + (y - this.rect.y1);
    };

    Camera.prototype.getWorldKey = function(x, y) {
      return (x + this.rect.x1) + ',' + (y + this.rect.y1);
    };

    Camera.prototype.getRect = function() {
      var x, y, _ref;
      _ref = [this.entity.getX() - Math.floor(this.width / 2), this.entity.getY() - Math.floor(this.height / 2)], x = _ref[0], y = _ref[1];
      return this.rect = Rect.fromWH(x, y, this.width, this.height);
    };

    return Camera;

  })();

  window.Camera = Camera;

}).call(this);
