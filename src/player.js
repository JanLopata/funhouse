//@ sourceMappingURL=player.map
// Generated by CoffeeScript 1.6.1
(function() {
  'use strict';
  var ALLOW_LEVEL_JUMPING, Attack, Beam, Bullet, Door, DownStairs, Entity, EventDispatcher, Food, GOD_MODE, HaBullet, Inventory, Item, Meter, Monster, Pickup, Player, Stairs, UpStairs, WhelkShell, action, controls, dir, direction, enemyStates, globalId, i, idleStatuses, key, keyCode, keyMap, keyName, rot_dirs, usefunc, xpForNextLevel, _i, _len,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  GOD_MODE = false;

  ALLOW_LEVEL_JUMPING = false;

  rot_dirs = ['up', 'up_right', 'right', 'down_right', 'down', 'down_left', 'left', 'up_left'];

  for (i = _i = 0, _len = rot_dirs.length; _i < _len; i = ++_i) {
    dir = rot_dirs[i];
    rot_dirs[dir] = i;
  }

  xpForNextLevel = function(level) {
    return Math.ceil(Math.pow(1.6, level) * 3) - 3;
  };

  idleStatuses = ['You yawn nervously.', 'You cringe as loud recorded laughter booms from a hidden speaker.', 'There\'s something sharp in your shoe.'];

  enemyStates = {
    hunting: 'Hunting'
  };

  window.constants = {
    lightPasses: 1,
    playerSightRadius: 20,
    playerSpeed: 100,
    hahaSpeedMultipler: 2,
    sprintMeleeMultiplier: 2,
    sprintDistance: 3,
    sprintStepBreathCost: 10,
    meleeBreathCost: 6,
    breathRecoveryStep: 1,
    idleStatusChance: .001,
    selfEsteemColor: '#0000aa',
    imaginationColor: '#880055',
    mirrorImaginationCost: 10
  };

  controls = {
    up: 'up',
    page_up: 'up_right',
    right: 'right',
    page_down: 'down_right',
    down: 'down',
    end: 'down_left',
    left: 'left',
    home: 'up_left',
    h: 'left',
    j: 'down',
    k: 'up',
    l: 'right',
    y: 'up_left',
    u: 'up_right',
    b: 'down_left',
    n: 'down_right',
    w: 'up',
    a: 'left',
    s: 'down',
    d: 'right',
    i: 'show_inventory'
  };

  if (ALLOW_LEVEL_JUMPING) {
    extend(controls, {
      z: 'prevLevel',
      x: 'nextLevel'
    });
  }

  keyMap = {};

  for (keyName in controls) {
    action = controls[keyName];
    key = 'VK_' + keyName.toUpperCase();
    assert(key, "unknown key " + keyName);
    keyCode = ROT[key];
    if ((direction = rot_dirs[action]) != null) {
      keyMap[keyCode] = direction;
    } else {
      keyMap[keyCode] = action;
    }
  }

  globalId = 1;

  Meter = (function() {

    function Meter(opts) {
      var val;
      for (key in opts) {
        val = opts[key];
        this[key] = val;
      }
    }

    Meter.prototype.add = function(val) {
      this.value = Math.min(this.max || 0, this.value + val);
      if (this.value < 0) {
        this.value = 0;
      }
      return this.value;
    };

    Meter.prototype.trySubtract = function(val) {
      if (this.value >= val) {
        this.value -= val;
        return true;
      }
    };

    return Meter;

  })();

  EventDispatcher = (function() {

    function EventDispatcher() {}

    EventDispatcher.prototype.publish = function() {
      var args, eventName, subscriber, subscriberList, subscribers, _j, _len1, _results;
      eventName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if ((subscribers = this._subscribers)) {
        if ((subscriberList = subscribers[eventName]) != null) {
          _results = [];
          for (_j = 0, _len1 = subscriberList.length; _j < _len1; _j++) {
            subscriber = subscriberList[_j];
            _results.push(subscriber.apply(null, args));
          }
          return _results;
        }
      }
    };

    EventDispatcher.prototype.subscribe = function(eventName, cb) {
      var subscriberList;
      if (!(subscriberList = this._subscribers[eventName])) {
        subscriberList = this._subscribers[eventName] = [];
      }
      return subscriberList.push(cb);
    };

    EventDispatcher.prototype.unsubscribeAll = function() {
      return delete this._subscribers;
    };

    return EventDispatcher;

  })();

  Entity = (function(_super) {

    __extends(Entity, _super);

    function Entity(level, _x, _y) {
      this.level = level;
      this._x = _x;
      this._y = _y;
      assert(this.level);
      assert(typeof this._x === 'number' && !isNaN(this._x));
      assert(typeof this._y === 'number' && !isNaN(this._x));
      this.guid = globalId;
      globalId += 1;
      this.level.addEntity(this, this._x, this._y);
    }

    Entity.prototype.charFunc = function(x, y) {
      return this.char;
    };

    Entity.prototype.triggerEffect = function(name, value) {
      var _ref;
      if ((_ref = this.effect) == null) {
        this.effect = {};
      }
      return this.effect[name] = value;
    };

    Entity.prototype.damage = function(opts) {
      var amount, entity, sentence, verb;
      amount = opts.amount;
      sentence = opts.sentence;
      if (sentence == null) {
        entity = opts.from;
        verb = opts.verb || 'damaged';
        sentence = '%s %s %s.'.format(entity.statusDesc(), verb, this.statusDesc());
        sentence = sentence[0].toUpperCase() + sentence.substr(1);
      }
      this.level.addStatus(sentence);
      if (this.health.add(-amount) === 0) {
        this.die();
      }
      return this.triggerEffect('damage', amount);
    };

    Entity.prototype.die = function() {
      this._dead = true;
      this.level.removeEntity(this);
      this.publish('dead');
      return this.unsubscribeAll();
    };

    Entity.prototype.makeMeter = function(name, opts) {
      var _ref;
      if (opts.value == null) {
        opts.value = opts.max;
      }
      if ((_ref = this._meters) == null) {
        this._meters = {};
      }
      return this._meters[name] = new Meter(opts);
    };

    Entity.prototype.statusDesc = function() {
      if (this.legendDesc != null) {
        if (this.needsThe) {
          return 'the ' + this.legendDesc;
        } else {
          return this.legendDesc;
        }
      }
      return this.constructor.name;
    };

    Entity.prototype.moveToLevel = function(newLevel, x, y) {
      assert(newLevel !== this.level);
      this.level.removeEntity(this);
      this.level = newLevel;
      this._x = x;
      this._y = y;
      return this.level.addEntity(this, x, y, {
        movingLevels: true
      });
    };

    Entity.prototype.getSpeed = function() {
      return constants.playerSpeed;
    };

    Entity.prototype.getX = function() {
      return this._x;
    };

    Entity.prototype.getY = function() {
      return this._y;
    };

    Entity.prototype.getKey = function() {
      return "" + this._x + "," + this._y;
    };

    Entity.prototype.position = function() {
      return [this._x, this._y];
    };

    Entity.prototype.bump = function() {};

    Entity.prototype.afterBump = function() {};

    Entity.prototype.setPosition = function(x, y) {
      this._x = x;
      return this._y = y;
    };

    return Entity;

  })(EventDispatcher);

  window.Entity = Entity;

  usefunc = function(opts) {
    var k, v;
    assert(opts.func);
    for (k in opts) {
      v = opts[k];
      if (k !== 'func') {
        opts.func[k] = v;
      }
    }
    opts.func._useFunc = true;
    return opts.func;
  };

  Door = (function(_super) {

    __extends(Door, _super);

    Door.prototype.blocksPathFinding = false;

    Door.prototype.blocksLight = true;

    Door.prototype.seeInFog = true;

    Door.prototype.bg = '#6e2311';

    function Door() {
      Door.__super__.constructor.apply(this, arguments);
      this.close();
    }

    Door.prototype.close = function() {
      return this.level.closedDoors[this.getKey()] = true;
    };

    Door.prototype.bump = function(e) {
      return delete this.level.closedDoors[this.getKey()];
    };

    Door.prototype.hideFromLegend = true;

    Door.prototype.char = '+';

    return Door;

  })(Entity);

  window.Door = Door;

  Item = (function(_super) {

    __extends(Item, _super);

    function Item() {
      return Item.__super__.constructor.apply(this, arguments);
    }

    Item.prototype.useFuncs = function() {
      var a, _ref, _results;
      _results = [];
      for (a in this) {
        if ((_ref = this[a]) != null ? _ref._useFunc : void 0) {
          _results.push(this[a]);
        }
      }
      return _results;
    };

    Item.prototype.blocksPathFinding = false;

    Item.prototype.seeInFog = true;

    Item.prototype.inventoryDesc = function() {
      return '';
    };

    Item.prototype.drop = usefunc({
      label: 'drop',
      func: function(inventory) {
        return inventory.drop(this);
      }
    });

    return Item;

  })(Entity);

  Pickup = (function(_super) {

    __extends(Pickup, _super);

    function Pickup() {
      return Pickup.__super__.constructor.apply(this, arguments);
    }

    Pickup.prototype.bump = function(entity) {
      return typeof entity.pickup === "function" ? entity.pickup(this) : void 0;
    };

    return Pickup;

  })(Item);

  Food = (function(_super) {

    __extends(Food, _super);

    function Food() {
      return Food.__super__.constructor.apply(this, arguments);
    }

    Food.prototype.statusDesc = function() {
      return 'food';
    };

    Food.prototype.inventoryDesc = function() {
      return 'Some food. Boosts your self-esteem.';
    };

    Food.prototype.char = '%';

    Food.prototype.color = 'red';

    Food.prototype.eat = usefunc({
      label: 'eat',
      func: function(inventory) {
        inventory.entity.eatFood(this);
        return inventory.remove(this);
      }
    });

    return Food;

  })(Pickup);

  window.Food = Food;

  WhelkShell = (function(_super) {

    __extends(WhelkShell, _super);

    WhelkShell.prototype.statusDesc = function() {
      return 'whelk shell';
    };

    WhelkShell.prototype.char = 'W';

    WhelkShell.prototype.inventoryDesc = function() {
      return 'A sprial shell, the kind you put up to your ear to hear the ocean.';
    };

    function WhelkShell() {
      WhelkShell.__super__.constructor.apply(this, arguments);
      this.imaginationValue = Math.floor(ROT.RNG.getNormal(20, 5));
    }

    WhelkShell.prototype.listen = usefunc({
      label: 'listen',
      func: function(inventory) {
        var entity, msg;
        entity = inventory.entity;
        msg = 'You place the shell to your ear, and hear the ocean. ';
        msg = msg + statusColor(constants.imaginationColor, '(+%s imagination)'.format(this.imaginationValue));
        entity.level.addStatus(msg);
        entity.imagination.add(this.imaginationValue);
        return inventory.remove(this);
      }
    });

    return WhelkShell;

  })(Pickup);

  window.WhelkShell = WhelkShell;

  Stairs = (function(_super) {

    __extends(Stairs, _super);

    function Stairs() {
      return Stairs.__super__.constructor.apply(this, arguments);
    }

    Stairs.prototype.color = 'yellow';

    Stairs.prototype.seeInFog = true;

    Stairs.prototype.afterBump = function(entity, opts) {
      if ((opts != null) && opts.movingLevels) {
        return;
      }
      return typeof entity.climbStairs === "function" ? entity.climbStairs(this) : void 0;
    };

    return Stairs;

  })(Entity);

  DownStairs = (function(_super) {

    __extends(DownStairs, _super);

    function DownStairs() {
      return DownStairs.__super__.constructor.apply(this, arguments);
    }

    DownStairs.prototype.char = '>';

    DownStairs.prototype.delta = 1;

    DownStairs.prototype.legendDesc = 'Stairs Down';

    return DownStairs;

  })(Stairs);

  UpStairs = (function(_super) {

    __extends(UpStairs, _super);

    function UpStairs() {
      return UpStairs.__super__.constructor.apply(this, arguments);
    }

    UpStairs.prototype.char = '<';

    UpStairs.prototype.delta = -1;

    UpStairs.prototype.legendDesc = 'Stairs Up';

    return UpStairs;

  })(Stairs);

  window.Stairs = Stairs;

  window.DownStairs = DownStairs;

  window.UpStairs = UpStairs;

  Inventory = (function() {

    function Inventory(entity) {
      this.entity = entity;
      this.items = [];
    }

    Inventory.prototype.remove = function(item) {
      return this.items.remove(item);
    };

    Inventory.prototype.drop = function(item) {
      var x, y, _ref;
      this.items.remove(item);
      this.entity.level.addStatus('You dropped the %s.'.format(item.statusDesc()));
      _ref = [this.entity.getX(), this.entity.getY()], x = _ref[0], y = _ref[1];
      item.setPosition(x, y);
      return this.entity.level.addEntity(item, x, y, {
        skipBump: true
      });
    };

    Inventory.prototype.pickup = function(item) {
      this.entity.level.removeEntity(item);
      return this.items.push(item);
    };

    return Inventory;

  })();

  Player = (function(_super) {

    __extends(Player, _super);

    Player.prototype.seesMirrors = true;

    Player.prototype.group = 'players';

    Player.prototype.toString = function() {
      return '<Player>';
    };

    Player.prototype.color = '#ff0';

    Player.prototype.statusDesc = function() {
      return 'you';
    };

    Player.prototype.char = '@';

    Player.prototype.legendDesc = 'You';

    Player.prototype.legendProps = [
      {
        type: 'bar',
        meter: 'health',
        label: 'Self-esteem',
        color: constants.selfEsteemColor
      }, {
        type: 'bar',
        meter: 'breath',
        label: 'Breath',
        color: '#667700'
      }, {
        type: 'bar',
        meter: 'imagination',
        label: 'Imagination',
        color: constants.imaginationColor
      }, {
        type: 'bar',
        meter: 'xpMeter',
        label: (function(entity) {
          return 'Level ' + entity.xplevel;
        }),
        color: '#006633'
      }
    ];

    function Player() {
      this.inventory = new Inventory(this);
      this.light = {
        color: [200, 200, 200]
      };
      this.health = this.makeMeter('health', {
        max: 100
      });
      this.breath = this.makeMeter('breath', {
        max: 100
      });
      this.imagination = this.makeMeter('imagination', {
        value: 20,
        max: 100
      });
      this.xp = 0;
      this.xplevel = 1;
      this._updateXP();
      Player.__super__.constructor.apply(this, arguments);
    }

    Player.prototype.awardXp = function(info) {
      if (typeof info.xp !== 'number') {
        console.log("ERROR: expected info.xp to be a number, got " + typeof info.xp);
        return;
      }
      this.xp += info.xp;
      return this._updateXP();
    };

    Player.prototype._updateXP = function() {
      var lastLevelUp, max, nextLevelUpAt, originalLevel, value;
      lastLevelUp = xpForNextLevel(this.xplevel - 1);
      nextLevelUpAt = xpForNextLevel(this.xplevel);
      originalLevel = this.xplevel;
      while (this.xp >= nextLevelUpAt) {
        this.xplevel += 1;
        lastLevelUp = xpForNextLevel(this.xplevel - 1);
        nextLevelUpAt = xpForNextLevel(this.xplevel);
      }
      if (this.xplevel > originalLevel) {
        this.didLevelUp();
      }
      max = nextLevelUpAt - lastLevelUp;
      value = this.xp - lastLevelUp;
      return this.xpMeter = this.makeMeter('xp', {
        value: value,
        max: max
      });
    };

    Player.prototype.didLevelUp = function() {
      return this.level.addStatus("You're now at level " + this.xplevel + ".");
    };

    Player.prototype.die = function() {
      if (GOD_MODE) {
        return;
      }
      this.level.addStatus('You died.');
      this.level.lock();
      return Player.__super__.die.apply(this, arguments);
    };

    Player.prototype.eatFood = function(food) {
      this.health.add(35);
      return this.level.addStatus('You ate the food. (+35 self-esteem)');
    };

    Player.prototype.pickup = function(item) {
      this.inventory.pickup(item);
      return this.level.addStatus('You picked up the %s.'.format(item.statusDesc()));
    };

    Player.prototype.climbStairs = function(stairs) {
      var entities;
      entities = this.level.allEntities();
      assert(entities.indexOf(this) !== -1);
      this.level.switchLevel(stairs.delta);
      if (stairs.delta === 1) {
        return this.level.addStatus('You tiptoe down the stairs. They creak anyways.');
      } else {
        return this.level.addStatus('You climb the stairs.');
      }
    };

    Player.prototype.act = function() {
      this.level.game.turn += 1;
      this.level.lock();
      return window.addEventListener('keydown', this);
    };

    Player.prototype.handleEvent = function(e) {
      var code, handler, newX, newY,
        _this = this;
      code = e.keyCode;
      if (e.altKey) {
        return;
      }
      if ((action = keyMap[code]) == null) {
        return;
      }
      e.preventDefault();
      if ((handler = this['on_' + action])) {
        window.removeEventListener('keydown', this);
        return handler.call(this, function(takeTurn) {
          if (takeTurn) {
            return _this.level.unlock();
          } else {
            return window.addEventListener('keydown', _this);
          }
        });
      }
      dir = ROT.DIRS[8][action];
      if (e.shiftKey) {
        this.trySprint(dir[0], dir[1]);
      } else {
        newX = this._x + dir[0];
        newY = this._y + dir[1];
        this.tryMoveTo(newX, newY);
      }
      window.removeEventListener("keydown", this);
      return this.level.unlock();
    };

    Player.prototype.on_show_inventory = function(after) {
      return showInventory(this.inventory, after);
    };

    Player.prototype.on_nextLevel = function(after) {
      this.level.switchLevel(1);
      return after(true);
    };

    Player.prototype.on_prevLevel = function(after) {
      if (this.level.depth > 1) {
        this.level.switchLevel(-1);
      }
      return after(true);
    };

    Player.prototype.melee = function(entity) {
      var amount;
      amount = 6;
      if (typeof opts !== "undefined" && opts !== null ? opts.sprinting : void 0) {
        amount *= constants.sprintMeleeMultiplier;
      }
      if (!this.breath.trySubtract(constants.meleeBreathCost)) {
        return this.level.addStatus('You try to hit %s, but you\'re wheezing.'.format(entity.statusDesc()));
      } else {
        return entity.damage({
          amount: amount,
          from: this,
          verb: 'punched'
        });
      }
    };

    Player.prototype.tryMoveTo = function(x, y, opts) {
      var entities, entity, moveInfo, skipBumpMsg, _j, _len1, _results;
      moveInfo = this.level.canMoveTo(x, y);
      if (!moveInfo.canMove) {
        skipBumpMsg = false;
        if (moveInfo.bumpFunc != null) {
          if (moveInfo.bumpFunc(this) === false) {
            skipBumpMsg = true;
          }
        }
        if (!skipBumpMsg && (moveInfo.bump != null)) {
          return this.level.addStatus(moveInfo.bump);
        }
      } else if ((entities = this.level.hostilesAtCell(x, y)).length) {
        _results = [];
        for (_j = 0, _len1 = entities.length; _j < _len1; _j++) {
          entity = entities[_j];
          this.melee(entity, opts);
          break;
        }
        return _results;
      } else {
        this.level.moveEntity(this, x, y);
        this.breath.add(constants.breathRecoveryStep);
        if (ROT.RNG.getUniform() < constants.idleStatusChance) {
          this.showIdleStatus();
        }
        return true;
      }
    };

    Player.prototype.showIdleStatus = function() {
      if (idleStatuses.length) {
        return this.level.addStatus(idleStatuses.removeRandom());
      }
    };

    Player.prototype.trySprint = function(x, y) {
      var didMove, dx, dy, newX, newY, sprintX, sprintY, _ref, _ref1, _ref2, _results;
      _ref = [x * constants.sprintDistance, y * constants.sprintDistance], sprintX = _ref[0], sprintY = _ref[1];
      didMove = false;
      _results = [];
      while (sprintX !== 0 || sprintY !== 0) {
        if (!this.breath.trySubtract(constants.sprintStepBreathCost)) {
          if (!didMove) {
            this.level.addStatus('You try to sprint, but you\'re out of breath.');
          }
          break;
        }
        _ref1 = [Math.sign(sprintX), Math.sign(sprintY)], dx = _ref1[0], dy = _ref1[1];
        _ref2 = [this._x + dx, this._y + dy], newX = _ref2[0], newY = _ref2[1];
        sprintX += -dx;
        sprintY += -dy;
        if (!this.tryMoveTo(newX, newY, {
          sprinting: true
        })) {
          break;
        }
        _results.push(didMove = true);
      }
      return _results;
    };

    Player.prototype._draw = function() {
      return {
        character: '@',
        color: "#ff0"
      };
    };

    return Player;

  })(Entity);

  window.Player = Player;

  Bullet = (function(_super) {

    __extends(Bullet, _super);

    function Bullet() {
      return Bullet.__super__.constructor.apply(this, arguments);
    }

    Bullet.prototype.blocksPathFinding = false;

    Bullet.prototype.seeInFog = true;

    Bullet.prototype.hideFromLegend = true;

    Bullet.prototype.damageOpts = function() {
      return {};
    };

    Bullet.prototype.bump = function(entity) {
      var opts;
      if (entity.group === 'players') {
        if (entity.damage) {
          opts = extend({
            amount: 3,
            from: this.sourceEntity || this
          }, this.damageOpts());
          entity.damage(opts);
          return this.die();
        }
      }
    };

    Bullet.prototype.act = function() {
      var target;
      target = vector.add(this.position(), this.velocity);
      this.level.moveEntity(this, target[0], target[1]);
      if (!this.level.canMoveTo(this._x, this._y).canMove) {
        return this.die();
      }
    };

    return Bullet;

  })(Entity);

  HaBullet = (function(_super) {

    __extends(HaBullet, _super);

    HaBullet.prototype.char = '*';

    HaBullet.prototype.getSpeed = function() {
      return constants.playerSpeed * constants.hahaSpeedMultipler;
    };

    HaBullet.prototype.drawOpts = function() {
      return {
        jiggle: [ROT.RNG.getUniform() * 4 - 2, ROT.RNG.getUniform() * 4 - 2]
      };
    };

    HaBullet.prototype.damageOpts = function() {
      return {
        verb: 'laughed at'
      };
    };

    function HaBullet(level, x, y, velocity, sourceEntity) {
      this.velocity = velocity;
      this.sourceEntity = sourceEntity;
      this.origin = [x, y];
      HaBullet.__super__.constructor.apply(this, arguments);
    }

    HaBullet.prototype.charFunc = function(x, y) {
      if ((x + y + this.level.game.turn) % 2 === 0) {
        return 'H';
      } else {
        return 'A';
      }
    };

    return HaBullet;

  })(Bullet);

  Attack = (function() {

    function Attack(entity) {
      this.entity = entity;
    }

    return Attack;

  })();

  Beam = (function(_super) {
    var beamWidth;

    __extends(Beam, _super);

    function Beam() {
      return Beam.__super__.constructor.apply(this, arguments);
    }

    beamWidth = 3;

    Beam.prototype.attackStatus = function() {
      return ['laughing maniacally', 'giggling', 'chuckling'].random();
    };

    Beam.prototype.fire = function(direction) {
      var a, n, otherEntities, startPos, _j, _ref, _results;
      startPos = this.entity.position();
      _results = [];
      for (n = _j = 1, _ref = constants.hahaSpeedMultipler + 1; 1 <= _ref ? _j <= _ref : _j >= _ref; n = 1 <= _ref ? ++_j : --_j) {
        startPos = vector.add(direction, startPos);
        otherEntities = (function() {
          var _k, _len1, _ref1, _results1;
          _ref1 = this.entity.level.entitiesAtCell(startPos[0], startPos[1]);
          _results1 = [];
          for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
            a = _ref1[_k];
            if (a instanceof HaBullet) {
              _results1.push(a);
            }
          }
          return _results1;
        }).call(this);
        if (otherEntities.length === 0) {
          _results.push(new HaBullet(this.entity.level, startPos[0], startPos[1], direction, this.entity));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Beam.prototype.shouldAttack = function(entityInfo) {
      var entity, _ref, _ref1;
      entity = entityInfo.entity;
      if ((_ref = entityInfo.closestCardinalTo) == null) {
        entityInfo.closestCardinalTo = vector.closestCardinal(entityInfo.vectorTo);
      }
      if ((_ref1 = entityInfo.lengthTo) == null) {
        entityInfo.lengthTo = vector.length(entityInfo.vectorTo);
      }
      if (entityInfo.lengthTo > 3 && entity.getX() === this.entity.getX() || entity.getY() === this.entity.getY()) {
        this.fire(entityInfo.closestCardinalTo);
        return true;
      }
    };

    return Beam;

  })(Attack);

  Monster = (function(_super) {

    __extends(Monster, _super);

    Monster.prototype.needsThe = true;

    Monster.prototype.hostile = true;

    Monster.prototype.char = "C";

    Monster.prototype.sightRadius = 15;

    Monster.prototype.legendDesc = 'Evil Clown';

    Monster.prototype.legendProps = [
      {
        type: 'bar',
        meter: 'health',
        label: 'Health'
      }
    ];

    Monster.prototype.xpValue = function() {
      return 1;
    };

    Monster.prototype.die = function() {
      this.level.awardXp({
        xp: this.xpValue()
      });
      return Monster.__super__.die.apply(this, arguments);
    };

    function Monster() {
      Monster.__super__.constructor.apply(this, arguments);
      this.attacks = [new Beam(this)];
      this.health = this.makeMeter('health', {
        max: 20
      });
    }

    Monster.prototype.attacks = {
      scratch: {
        verb: 'scratches',
        damage: 3
      }
    };

    Monster.prototype.act = function() {
      var entity, length, myPosition, vectorTo, _j, _len1, _ref;
      myPosition = this.position();
      _ref = this.visibleEntities('players');
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        entity = _ref[_j];
        this.lastSeenPos = entity.position();
        vectorTo = vector.subtract(this.lastSeenPos, myPosition);
        length = vector.length(vectorTo);
        if (length < 2) {
          this.attack(entity);
          return;
        } else {
          if (this.chooseAttack({
            entity: entity,
            vectorTo: vectorTo
          })) {
            return;
          }
        }
      }
      if (this.lastSeenPos != null) {
        this.state = enemyStates.hunting;
        return this.headTowards(this.lastSeenPos[0], this.lastSeenPos[1]);
      }
    };

    Monster.prototype.chooseAttack = function(entityInfo) {
      var attack, state, _j, _len1, _ref;
      _ref = this.attacks;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        attack = _ref[_j];
        if (attack.shouldAttack(entityInfo)) {
          if ((state = typeof attack.attackStatus === "function" ? attack.attackStatus() : void 0)) {
            this.state = state;
          }
          return true;
        }
      }
    };

    Monster.prototype.attack = function(entity) {
      if (entity != null ? entity.damage : void 0) {
        return entity.damage({
          amount: 3,
          from: this,
          verb: ['smacked', 'punched'].random()
        });
      }
    };

    Monster.prototype.headTowards = function(x, y) {
      var astar, passableCallback, path,
        _this = this;
      passableCallback = function(x, y) {
        return _this.level.canMoveTo(x, y, {
          entities: true,
          self: _this
        }).canMove;
      };
      astar = new ROT.Path.AStar(x, y, passableCallback, {
        topology: 8
      });
      path = [];
      astar.compute(this._x, this._y, function(x, y) {
        return path.push([x, y]);
      });
      path.shift();
      if (path.length) {
        return this.level.moveEntity(this, path[0][0], path[0][1]);
      }
    };

    Monster.prototype.visibleEntities = function(inGroup) {
      var groupTest, vis, _ref,
        _this = this;
      if ((_ref = this.fov) == null) {
        this.fov = this.level.createFOV();
      }
      groupTest = inGroup != null ? function(e) {
        return e.group === inGroup;
      } : function(e) {
        return true;
      };
      vis = [];
      this.fov.compute(this._x, this._y, this.sightRadius, function(x, y, r, visible) {
        var e, entities;
        if (visible) {
          entities = (function() {
            var _j, _len1, _ref1, _results;
            _ref1 = this.level.entitiesAtCell(x, y);
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              e = _ref1[_j];
              if (groupTest(e)) {
                _results.push(e);
              }
            }
            return _results;
          }).call(_this);
          return vis = vis.concat(entities);
        }
      });
      return vis;
    };

    return Monster;

  })(Entity);

  window.Monster = Monster;

}).call(this);
