//@ sourceMappingURL=player.map
// Generated by CoffeeScript 1.6.1
(function() {
  'use strict';
  var DownStairs, Entity, Food, Item, Meter, Monster, Player, Stairs, UpStairs, action, constants, controls, dir, direction, globalId, i, key, keyMap, keyName, rot_dirs, _i, _len,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  rot_dirs = ['up', 'up_right', 'right', 'down_right', 'down', 'down_left', 'left', 'up_left'];

  for (i = _i = 0, _len = rot_dirs.length; _i < _len; i = ++_i) {
    dir = rot_dirs[i];
    rot_dirs[dir] = i;
  }

  constants = {
    sprintMeleeMultiplier: 2,
    sprintDistance: 3,
    sprintStepBreathCost: 10,
    breathRecoveryStep: 1
  };

  controls = {
    up: 'up',
    page_up: 'up_right',
    right: 'right',
    page_down: 'down_right',
    down: 'down',
    end: 'down_left',
    left: 'left',
    home: 'up_left',
    h: 'left',
    j: 'down',
    k: 'up',
    l: 'right',
    y: 'up_left',
    u: 'up_right',
    b: 'down_left',
    n: 'down_right',
    w: 'up',
    a: 'left',
    s: 'down',
    d: 'right'
  };

  keyMap = {};

  for (keyName in controls) {
    action = controls[keyName];
    key = 'VK_' + keyName.toUpperCase();
    assert(key, "unknown key " + keyName);
    direction = rot_dirs[action];
    assert(direction !== void 0, "could not find a direction for " + action);
    keyMap[ROT[key]] = rot_dirs[action];
  }

  globalId = 1;

  Meter = (function() {

    function Meter(opts) {
      var val;
      for (key in opts) {
        val = opts[key];
        this[key] = val;
      }
    }

    Meter.prototype.add = function(val) {
      this.value = Math.min(this.max || 0, this.value + val);
      if (this.value < 0) {
        this.value = 0;
      }
      return this.value;
    };

    Meter.prototype.trySubtact = function(val) {
      if (this.value >= val) {
        this.value -= val;
        return true;
      }
    };

    return Meter;

  })();

  Entity = (function() {

    Entity.prototype.triggerEffect = function(name, value) {
      var _ref;
      if ((_ref = this.effect) == null) {
        this.effect = {};
      }
      return this.effect[name] = value;
    };

    Entity.prototype.damage = function(opts) {
      var amount, entity;
      entity = opts.from;
      amount = opts.amount;
      this.level.addStatus('%s damaged %s.'.format(entity.statusDesc(), this.statusDesc()));
      if (this.health.add(-amount) === 0) {
        this.die();
      }
      return this.triggerEffect('damage', amount);
    };

    Entity.prototype.die = function() {
      return this.level.removeEntity(this);
    };

    Entity.prototype.makeMeter = function(name, opts) {
      var _ref;
      if (opts.value == null) {
        opts.value = opts.max;
      }
      if ((_ref = this._meters) == null) {
        this._meters = {};
      }
      return this._meters[name] = new Meter(opts);
    };

    Entity.prototype.statusDesc = function() {
      return this.legendDesc || this.constructor.name;
    };

    function Entity(level, _x, _y) {
      this.level = level;
      this._x = _x;
      this._y = _y;
      assert(this.level);
      this.guid = globalId;
      globalId += 1;
      this.level.addEntity(this, this._x, this._y);
    }

    Entity.prototype.moveToLevel = function(newLevel, x, y) {
      assert(newLevel !== this.level);
      this.level.removeEntity(this);
      this.level = newLevel;
      this._x = x;
      this._y = y;
      return this.level.addEntity(this, x, y);
    };

    Entity.prototype.getSpeed = function() {
      return 100;
    };

    Entity.prototype.getX = function() {
      return this._x;
    };

    Entity.prototype.getY = function() {
      return this._y;
    };

    Entity.prototype.position = function() {
      return [this._x, this._y];
    };

    Entity.prototype.bump = function() {};

    Entity.prototype.afterBump = function() {};

    Entity.prototype.setPosition = function(x, y) {
      this._x = x;
      return this._y = y;
    };

    return Entity;

  })();

  window.Entity = Entity;

  Item = (function(_super) {

    __extends(Item, _super);

    function Item() {
      return Item.__super__.constructor.apply(this, arguments);
    }

    Item.prototype.seeInFog = true;

    return Item;

  })(Entity);

  Food = (function(_super) {

    __extends(Food, _super);

    function Food() {
      return Food.__super__.constructor.apply(this, arguments);
    }

    Food.prototype.char = '%';

    Food.prototype.color = 'red';

    Food.prototype.bump = function(entity) {
      return typeof entity.eatFood === "function" ? entity.eatFood(this) : void 0;
    };

    return Food;

  })(Item);

  window.Food = Food;

  Stairs = (function(_super) {

    __extends(Stairs, _super);

    function Stairs() {
      return Stairs.__super__.constructor.apply(this, arguments);
    }

    Stairs.prototype.color = 'yellow';

    Stairs.prototype.seeInFog = true;

    Stairs.prototype.afterBump = function(entity) {
      return typeof entity.climbStairs === "function" ? entity.climbStairs(this) : void 0;
    };

    return Stairs;

  })(Entity);

  DownStairs = (function(_super) {

    __extends(DownStairs, _super);

    function DownStairs() {
      return DownStairs.__super__.constructor.apply(this, arguments);
    }

    DownStairs.prototype.char = '>';

    DownStairs.prototype.delta = 1;

    DownStairs.prototype.legendDesc = 'Stairs Down';

    return DownStairs;

  })(Stairs);

  UpStairs = (function(_super) {

    __extends(UpStairs, _super);

    function UpStairs() {
      return UpStairs.__super__.constructor.apply(this, arguments);
    }

    UpStairs.prototype.char = '<';

    UpStairs.prototype.delta = -1;

    UpStairs.prototype.legendDesc = 'Stairs Up';

    return UpStairs;

  })(Stairs);

  window.Stairs = Stairs;

  window.DownStairs = DownStairs;

  window.UpStairs = UpStairs;

  Player = (function(_super) {

    __extends(Player, _super);

    Player.prototype.seesMirrors = true;

    Player.prototype.group = 'players';

    Player.prototype.toString = function() {
      return '<Player>';
    };

    Player.prototype.color = '#ff0';

    Player.prototype.char = '@';

    Player.prototype.legendDesc = 'You';

    Player.prototype.legendProps = [
      {
        type: 'bar',
        meter: 'health',
        label: 'Self-esteem'
      }, {
        type: 'bar',
        meter: 'breath',
        label: 'Breath',
        color: '#006633'
      }, {
        type: 'bar',
        meter: 'imagination',
        label: 'Imagination',
        color: '#880055'
      }
    ];

    function Player() {
      Player.__super__.constructor.apply(this, arguments);
      this.numFoods = 0;
      this.light = {
        color: [200, 200, 200]
      };
      this.health = this.makeMeter('health', {
        max: 100
      });
      this.breath = this.makeMeter('breath', {
        max: 100
      });
      this.imagination = this.makeMeter('imagination', {
        max: 100
      });
    }

    Player.prototype.die = function() {
      this.level.addStatus('You died.');
      return this.level.lock();
    };

    Player.prototype.eatFood = function(food) {
      this.numFoods += 1;
      this.level.removeEntity(food);
      return this.level.addStatus('You ate a food.');
    };

    Player.prototype.climbStairs = function(stairs) {
      var entities;
      entities = this.level.allEntities();
      assert(entities.indexOf(this) !== -1);
      this.level.switchLevel(stairs.delta);
      if (stairs.delta === 1) {
        return this.level.addStatus('You tiptoe down the stairs. They creak anyways.');
      } else {
        return this.level.addStatus('You climb the stairs.');
      }
    };

    Player.prototype.act = function() {
      this.level.lock();
      return window.addEventListener('keydown', this);
    };

    Player.prototype.handleEvent = function(e) {
      var code, newX, newY;
      code = e.keyCode;
      if (e.altKey) {
        return;
      }
      if (!(code in keyMap)) {
        return;
      }
      e.preventDefault();
      dir = ROT.DIRS[8][keyMap[code]];
      if (e.shiftKey) {
        this.trySprint(dir[0], dir[1]);
      } else {
        newX = this._x + dir[0];
        newY = this._y + dir[1];
        this.tryMoveTo(newX, newY);
      }
      window.removeEventListener("keydown", this);
      return this.level.unlock();
    };

    Player.prototype.melee = function(entity) {
      var amount;
      amount = 6;
      if (typeof opts !== "undefined" && opts !== null ? opts.sprinting : void 0) {
        amount *= constants.sprintMeleeMultiplier;
      }
      return entity.damage({
        amount: amount,
        from: this
      });
    };

    Player.prototype.tryMoveTo = function(x, y, opts) {
      var entities, entity, moveInfo, _j, _len1, _results;
      moveInfo = this.level.canMoveTo(x, y);
      if (!moveInfo.canMove) {
        if (moveInfo.bump != null) {
          return this.level.addStatus(moveInfo.bump);
        }
      } else if ((entities = this.level.hostilesAtCell(x, y)).length) {
        _results = [];
        for (_j = 0, _len1 = entities.length; _j < _len1; _j++) {
          entity = entities[_j];
          this.melee(entity, opts);
          break;
        }
        return _results;
      } else {
        this.level.moveEntity(this, x, y);
        this.breath.add(constants.breathRecoveryStep);
        return true;
      }
    };

    Player.prototype.trySprint = function(x, y) {
      var didMove, dx, dy, newX, newY, sprintX, sprintY, _ref, _ref1, _ref2, _results;
      _ref = [x * constants.sprintDistance, y * constants.sprintDistance], sprintX = _ref[0], sprintY = _ref[1];
      didMove = false;
      _results = [];
      while (sprintX !== 0 || sprintY !== 0) {
        if (!this.breath.trySubtact(constants.sprintStepBreathCost)) {
          if (!didMove) {
            this.level.addStatus('You try to sprint, but you\'re out of breath.');
          }
          break;
        }
        _ref1 = [Math.sign(sprintX), Math.sign(sprintY)], dx = _ref1[0], dy = _ref1[1];
        _ref2 = [this._x + dx, this._y + dy], newX = _ref2[0], newY = _ref2[1];
        sprintX += -dx;
        sprintY += -dy;
        if (!this.tryMoveTo(newX, newY, {
          sprinting: true
        })) {
          break;
        }
        _results.push(didMove = true);
      }
      return _results;
    };

    Player.prototype._draw = function() {
      return {
        character: '@',
        color: "#ff0"
      };
    };

    return Player;

  })(Entity);

  window.Player = Player;

  Monster = (function(_super) {

    __extends(Monster, _super);

    Monster.prototype.hostile = true;

    Monster.prototype.char = "&";

    Monster.prototype.sightRadius = 15;

    Monster.prototype.legendProps = [
      {
        type: 'bar',
        meter: 'health',
        label: 'Health'
      }
    ];

    function Monster() {
      Monster.__super__.constructor.apply(this, arguments);
      this.health = this.makeMeter('health', {
        max: 20
      });
    }

    Monster.prototype.attacks = {
      scratch: {
        verb: 'scratches',
        damage: 3
      }
    };

    Monster.prototype.act = function() {
      var entity, _j, _len1, _ref, _ref1;
      _ref = this.visibleEntities();
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        entity = _ref[_j];
        if (entity.group === 'players') {
          _ref1 = entity.position(), this.lastX = _ref1[0], this.lastY = _ref1[1];
          if (Point.distance(entity.position(), this.position()) < 2) {
            this.attack(entity);
            return;
          }
        }
      }
      if (this.lastX != null) {
        return this.headTowards(this.lastX, this.lastY);
      }
    };

    Monster.prototype.attack = function(entity) {
      if (entity != null ? entity.damage : void 0) {
        return entity.damage({
          amount: 3,
          from: this
        });
      }
    };

    Monster.prototype.headTowards = function(x, y) {
      var astar, passableCallback, path,
        _this = this;
      passableCallback = function(x, y) {
        return _this.level.canMoveTo(x, y, {
          entities: true,
          self: _this
        }).canMove;
      };
      astar = new ROT.Path.AStar(x, y, passableCallback, {
        topology: 8
      });
      path = [];
      astar.compute(this._x, this._y, function(x, y) {
        return path.push([x, y]);
      });
      path.shift();
      if (path.length) {
        return this.level.moveEntity(this, path[0][0], path[0][1]);
      }
    };

    Monster.prototype.visibleEntities = function() {
      var vis, _ref,
        _this = this;
      if ((_ref = this.fov) == null) {
        this.fov = this.level.createFOV();
      }
      vis = [];
      this.fov.compute(this._x, this._y, this.sightRadius, function(x, y, r, visible) {
        if (visible) {
          return vis = vis.concat(_this.level.entitiesAtCell(x, y));
        }
      });
      return vis;
    };

    return Monster;

  })(Entity);

  window.Monster = Monster;

}).call(this);
